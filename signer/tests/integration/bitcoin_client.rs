mod serial {
    use std::time::Duration;

    use bitcoin::absolute::LockTime;
    use bitcoin::hashes::Hash as _;
    use bitcoin::transaction::Version;
    use bitcoin::{AddressType, Amount, BlockHash, ScriptBuf, Sequence, Witness};
    use bitcoincore_rpc::RpcApi as _;
    use sbtc::testing::regtest::{
        self, AsUtxo as _, BITCOIN_CORE_RPC_ENDPOINT, BITCOIN_CORE_RPC_PASSWORD,
        BITCOIN_CORE_RPC_USERNAME, Recipient, p2wpkh_sign_transaction,
    };
    use signer::bitcoin::rpc::{BitcoinCoreClient, BitcoinCoreClientParams};
    use signer::bitcoin::{BitcoinInteract as _, TransactionLookupHint};
    use signer::util::ApiFallbackClient;
    use url::Url;

    #[tokio::test]
    async fn test_get_block_not_found() {
        let url: Url = format!(
            "http://{BITCOIN_CORE_RPC_USERNAME}:{BITCOIN_CORE_RPC_PASSWORD}@{}",
            BITCOIN_CORE_RPC_ENDPOINT.strip_prefix("http://").unwrap()
        )
        .parse()
        .unwrap();

        let bitcoin_client_params = BitcoinCoreClientParams {
            url,
            timeout: Duration::from_secs(10),
        };

        let client = BitcoinCoreClient::try_from(&bitcoin_client_params).unwrap();
        let result = client.inner_client().get_block(&BlockHash::all_zeros());

        // This will return: JsonRpc(Rpc(RpcError { code: -5, message: "Block not found", data: None }))
        assert!(matches!(
            result.unwrap_err(),
            bitcoincore_rpc::Error::JsonRpc(bitcoincore_rpc::jsonrpc::Error::Rpc(rpc_error))
                if rpc_error.code == -5
        ))
    }

    // TODO: Figure out how to let this (and similar tests) run against the wallet
    // generated by `initialize_blockchain()`. See comment in the test below.
    #[tokio::test]
    async fn test_get_block_works() {
        let (_, faucet) = regtest::initialize_blockchain();
        let blocks = faucet.generate_blocks(5);

        let url: Url = format!(
            "http://{BITCOIN_CORE_RPC_USERNAME}:{BITCOIN_CORE_RPC_PASSWORD}@{}",
            BITCOIN_CORE_RPC_ENDPOINT.strip_prefix("http://").unwrap()
        )
        .parse()
        .unwrap();

        let bitcoin_client_params = BitcoinCoreClientParams {
            url,
            timeout: Duration::from_secs(10),
        };

        let client = ApiFallbackClient::<BitcoinCoreClient>::new(vec![
            BitcoinCoreClient::try_from(&bitcoin_client_params).unwrap(),
        ])
        .unwrap();

        // Double-check that an all-zero block doesn't return an error or something else unexpected.
        let block = client.get_block(&BlockHash::all_zeros()).await;
        assert!(block.is_ok_and(|x| x.is_none()));

        for block_hash in blocks.iter() {
            let b = client
                .get_block(block_hash)
                .await
                .expect("failed to get block")
                .expect("expected to receive a block, not None");

            assert_eq!(b.block_hash, *block_hash);
        }
    }

    #[tokio::test]
    async fn calculate_transaction_fee_works_confirmed() {
        let client = BitcoinCoreClient::new(
            regtest::BITCOIN_CORE_RPC_ENDPOINT,
            regtest::BITCOIN_CORE_RPC_USERNAME.to_string(),
            regtest::BITCOIN_CORE_RPC_PASSWORD.to_string(),
            Duration::from_secs(10),
        )
        .unwrap();

        let (rpc, faucet) = regtest::initialize_blockchain();
        let addr1 = Recipient::new(AddressType::P2wpkh);

        // Get some coins to spend (and our "utxo" outpoint).
        let outpoint = faucet.send_to(500_000, &addr1.address);
        // A coinbase transaction is not spendable until it has 100 confirmations.
        faucet.generate_blocks(1);

        // Get a utxo to spend (this method gives us an `AsUtxo` type which is
        // needed for signing below).
        let utxo = addr1.get_utxos(rpc, Some(1_000)).pop().unwrap();
        assert_eq!(utxo.outpoint(), outpoint);

        // Create a transaction that spends the utxo.
        let mut tx = bitcoin::Transaction {
            version: Version::ONE,
            lock_time: LockTime::ZERO,
            input: vec![bitcoin::TxIn {
                previous_output: utxo.outpoint(),
                script_sig: ScriptBuf::new(),
                sequence: Sequence::ZERO,
                witness: Witness::new(),
            }],
            output: vec![
                bitcoin::TxOut {
                    value: Amount::from_sat(1_000),
                    script_pubkey: addr1.address.script_pubkey(),
                },
                bitcoin::TxOut {
                    value: utxo.amount - Amount::from_sat(1_000) * 2,
                    script_pubkey: addr1.address.script_pubkey(),
                },
            ],
        };

        // Sign and broadcast the transaction
        p2wpkh_sign_transaction(&mut tx, 0, &utxo, &addr1.keypair);
        let txid = tx.compute_txid();
        client.broadcast_transaction(&tx).await.unwrap();
        // Confirm the transaction
        let block_hash = faucet.generate_blocks(1).pop().unwrap();

        let _ = client
            .get_tx_info(&txid, &block_hash)
            .unwrap()
            .expect("expected to be able to retrieve txinfo verbosity 2 for confirmed tx");

        let result = client
            .get_transaction_fee(&txid, Some(TransactionLookupHint::Confirmed))
            .await
            .expect("failed to calculate transaction fee");

        let expected_fee_total =
            utxo.amount.to_sat() - tx.output.iter().map(|o| o.value.to_sat()).sum::<u64>();
        let expected_fee_rate = expected_fee_total as f64 / tx.vsize() as f64;

        assert_eq!(result.fee, expected_fee_total);
        assert_eq!(result.fee_rate, expected_fee_rate);
    }

    #[tokio::test]
    async fn calculate_transaction_fee_works_mempool() {
        let client = BitcoinCoreClient::new(
            regtest::BITCOIN_CORE_RPC_ENDPOINT,
            regtest::BITCOIN_CORE_RPC_USERNAME.to_string(),
            regtest::BITCOIN_CORE_RPC_PASSWORD.to_string(),
            Duration::from_secs(10),
        )
        .unwrap();

        let (rpc, faucet) = regtest::initialize_blockchain();
        let addr1 = Recipient::new(AddressType::P2wpkh);

        // Get some coins to spend (and our "utxo" outpoint).
        let outpoint = faucet.send_to(500_000, &addr1.address);
        // A coinbase transaction is not spendable until it has 100 confirmations.
        faucet.generate_blocks(1);

        // Get a utxo to spend (this method gives us an `AsUtxo` type which is
        // needed for signing below).
        let utxo = addr1.get_utxos(rpc, Some(1_000)).pop().unwrap();
        assert_eq!(utxo.outpoint(), outpoint);

        // Create a transaction that spends the utxo.
        let mut tx = bitcoin::Transaction {
            version: Version::ONE,
            lock_time: LockTime::ZERO,
            input: vec![bitcoin::TxIn {
                previous_output: utxo.outpoint(),
                script_sig: ScriptBuf::new(),
                sequence: Sequence::ZERO,
                witness: Witness::new(),
            }],
            output: vec![
                bitcoin::TxOut {
                    value: Amount::from_sat(1_000),
                    script_pubkey: addr1.address.script_pubkey(),
                },
                bitcoin::TxOut {
                    value: utxo.amount - Amount::from_sat(1_000) * 2,
                    script_pubkey: addr1.address.script_pubkey(),
                },
            ],
        };

        // Sign and broadcast the transaction
        p2wpkh_sign_transaction(&mut tx, 0, &utxo, &addr1.keypair);
        client.broadcast_transaction(&tx).await.unwrap();

        let result = client
            .get_transaction_fee(&tx.compute_txid(), Some(TransactionLookupHint::Mempool))
            .await
            .expect("failed to calculate transaction fee");

        let expected_fee_total =
            utxo.amount.to_sat() - tx.output.iter().map(|o| o.value.to_sat()).sum::<u64>();
        let expected_fee_rate = expected_fee_total as f64 / tx.vsize() as f64;

        assert_eq!(result.fee, expected_fee_total);
        assert_eq!(result.fee_rate, expected_fee_rate);
    }
}
